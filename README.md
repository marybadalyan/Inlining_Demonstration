#### 1. What is a Tight Loop?

A **tight loop** is a loop containing a very small number of instructions that executes a very high number of times. Its efficiency comes from minimizing the work done inside the loop, but this can also make it "CPU-bound," consuming processor resources and potentially making an application unresponsive if not handled carefully.

#### 2. The Problem with Function Calls in Tight Loops

Placing a standard function call inside a tight loop is generally bad for performance. Every call introduces significant **function call overhead**:
* Saving the current state (registers, instruction pointer).
* Passing parameters to the new function.
* Jumping to a new location in memory.
* Returning from the function and restoring the state.

This overhead, repeated millions of times, can easily become the main performance bottleneck, dwarfing the actual work the function performs.

#### 3. How Compilers Optimize This: Loop Unrolling

To combat loop overhead, compilers use a technique called **loop unrolling**. Instead of executing a loop's body once per iteration, the compiler duplicates the body to perform several iterations' worth of work in a single pass.

* **Before:** `for (i=0; i<100; i++) { work(i); }` (100 jumps, 100 compares)
* **After:** `for (i=0; i<100; i+=4) { work(i); work(i+1); work(i+2); work(i+3); }` (25 jumps, 25 compares)

This drastically reduces the ratio of overhead (jumps/compares) to useful work, leading to significant speedups. This is a classic **space-time tradeoff**, as it increases the final program size to decrease its execution time.

#### 4. Proving It: Analysis Through Disassembly

These compiler optimizations are not magic; they are concrete changes that can be observed by inspecting the **assembly code** (`.s` or `.asm` file) generated by the compiler. By comparing the disassembly of an unoptimized build (`-O0` or `/Od`) with a highly optimized one (`-O2` or `-O3`), you can definitively see optimizations like loop unrolling and function inlining in action.

#### 5. Unlocking Deeper Performance: Instruction-Level Parallelism

Loop unrolling isn't just about reducing overhead. It also helps unlock **Instruction-Level Parallelism (ILP)**. A simple unrolled loop like `sum += a[i]; sum += a[i+1];` appears to have a **data dependency**, as each operation depends on the result of the last.

However, a smart compiler knows that addition is associative. It can break this dependency chain by using multiple temporary "accumulator" variables, like so:
```cpp
sum1 += a[i];   // Independent
sum2 += a[i+1]; // Independent
sum3 += a[i+2]; // Independent
sum4 += a[i+3]; // Independent
...
final_sum = sum1 + sum2 + sum3 + sum4; // Combine at the end
```
This allows a modern CPU to execute all four additions simultaneously, providing a massive performance boost.

#### 6. Taking Control: How to Force Inlining

Sometimes, a compiler's heuristics will decide not to inline a function even with optimizations enabled. To override this, we can use compiler-specific commands:

* **`inline` keyword:** In modern C++, this is primarily a hint and a directive to the linker to allow definitions in header files. It does **not** guarantee inlining.
* **`__forceinline` (MSVC):** A direct command to the Microsoft C++ compiler to inline a function if possible.
* **`__attribute__((always_inline))` (GCC/Clang):** A direct command to GCC and Clang to do the same.

Forcing inlining is a powerful tool but should be used with care after profiling, as it can lead to "code bloat" and potentially harm performance by overflowing the CPU's instruction cache.

#### 7. Integrating with Build Systems (like CMake)

The `__forceinline` keywords are **not compiler flags**; they are attributes written directly in the source code. To control them from a `CMakeLists.txt` or other build file, the standard professional practice is to:

1.  **Wrap the attribute in a C++ preprocessor macro** in a header file.
    ```cpp
    #ifdef ENABLE_FORCE_INLINING
      #define FORCE_INLINE __forceinline
    #else
      #define FORCE_INLINE inline
    #endif
    ```
2.  **Define that macro from CMake** using `target_compile_definitions` for specific targets and configurations.
    ```cmake
    # This enables FORCE_INLINE for the 'my_app' target only in Release builds.
    target_compile_definitions(my_app PRIVATE $<$<CONFIG:Release>:ENABLE_FORCE_INLINING>)
    ```


### How to Build and Run
#### Prerequisites
- A C++ compiler (GCC, Clang, or MSVC)
- CMake (version 3.10 or higher)
- git (to clone the repository)

#### Steps
Clone the repository:

```bash
git clone <Inligning_Demonstration>
cd <Inligning_Demonstration>
```

Configure the project using CMake:
This will create a build directory and generate the build files for your system.

```bash
cmake -B build
```
Build the executables:
This will compile main.cpp twice with the different optimization flags and run the post-build commands to generate the assembly files.

```bash
cmake --build build
```

Run the analysis:
The final executables need to be run from the build directory. You must provide the path to the assembly file and the optimization level string as arguments.


# Run the optimized version

```bash
./build/Release/inlining_test.exe  build//analysis//assembly_Release.txt O2
```
# Run the unoptimized version
```bash
./build/Debug/inlining_test.exe  build//analysis//assembly_Debug.txt Od
```
You will see the colored output in your terminal, comparing the performance and code size of the two optimization levels.



### Example Output

```bash
Assembly Path:      build//analysis//assembly_Release.txt
Optimization Level: O2
Time Taken:         3.35e-05 seconds
Final Result:       459600

--- Assembly for run() ---
  0000000000000000: 48 89 5C 24 08     mov         qword ptr [rsp+8],rbx
  0000000000000005: 48 89 6C 24 10     mov         qword ptr [rsp+10h],rbp
  000000000000000A: 48 89 74 24 20     mov         qword ptr [rsp+20h],rsi
  000000000000000F: 57                 push        rdi
  0000000000000010: 41 56              push        r14
  0000000000000012: 44 8B 35 00 00 00  mov         r14d,dword ptr [__isa_available]
                    00
  0000000000000019: 4C 8B D9           mov         r11,rcx
  000000000000001C: 48 63 FA           movsxd      rdi,edx
  000000000000001F: 33 F6              xor         esi,esi
  0000000000000021: 48 8B DF           mov         rbx,rdi
  0000000000000024: BD 64 00 00 00     mov         ebp,64h
  0000000000000029: 0F 1F 80 00 00 00  nop         dword ptr [rax]
                    00
  0000000000000030: 45 33 C9           xor         r9d,r9d
  0000000000000033: 33 C0              xor         eax,eax
  0000000000000035: 85 FF              test        edi,edi
  0000000000000037: 7E 4E              jle         0000000000000087
  0000000000000039: 83 FF 04           cmp         edi,4
  000000000000003C: 72 49              jb          0000000000000087
  000000000000003E: 41 83 FE 02        cmp         r14d,2
  0000000000000042: 7C 43              jl          0000000000000087
  0000000000000044: 48 8B CF           mov         rcx,rdi
  0000000000000047: 0F 57 DB           xorps       xmm3,xmm3
  000000000000004A: 48 83 E1 FC        and         rcx,0FFFFFFFFFFFFFFFCh
  000000000000004E: 0F 57 D2           xorps       xmm2,xmm2
  0000000000000051: 66 41 0F 38 25 0C  pmovsxdq    xmm1,mmword ptr [r11+rax*4]
                    83
  0000000000000058: 66 0F D4 D9        paddq       xmm3,xmm1
  000000000000005C: 66 41 0F 38 25 4C  pmovsxdq    xmm1,mmword ptr [r11+rax*4+8]
                    83 08
  0000000000000064: 48 83 C0 04        add         rax,4
  0000000000000068: 66 0F D4 D1        paddq       xmm2,xmm1
  000000000000006C: 48 3B C1           cmp         rax,rcx
  000000000000006F: 7C E0              jl          0000000000000051
  0000000000000071: 66 0F D4 D3        paddq       xmm2,xmm3
  0000000000000075: 66 0F 6F C2        movdqa      xmm0,xmm2
  0000000000000079: 66 0F 73 D8 08     psrldq      xmm0,8
  000000000000007E: 66 0F D4 D0        paddq       xmm2,xmm0
  0000000000000082: 66 49 0F 7E D1     movq        r9,xmm2
  0000000000000087: 33 D2              xor         edx,edx
  0000000000000089: 45 33 C0           xor         r8d,r8d
  000000000000008C: 48 3B C3           cmp         rax,rbx
  000000000000008F: 7D 3B              jge         00000000000000CC
  0000000000000091: 48 8B CB           mov         rcx,rbx
  0000000000000094: 48 2B C8           sub         rcx,rax
  0000000000000097: 48 83 F9 02        cmp         rcx,2
  000000000000009B: 7C 21              jl          00000000000000BE
  000000000000009D: 4C 8D 57 FF        lea         r10,[rdi-1]
  00000000000000A1: 49 63 0C 83        movsxd      rcx,dword ptr [r11+rax*4]
  00000000000000A5: 48 03 D1           add         rdx,rcx
  00000000000000A8: 49 63 4C 83 04     movsxd      rcx,dword ptr [r11+rax*4+4]
  00000000000000AD: 4C 03 C1           add         r8,rcx
  00000000000000B0: 48 83 C0 02        add         rax,2
  00000000000000B4: 49 3B C2           cmp         rax,r10
  00000000000000B7: 7C E8              jl          00000000000000A1
  00000000000000B9: 48 3B C3           cmp         rax,rbx
  00000000000000BC: 7D 07              jge         00000000000000C5
  00000000000000BE: 49 63 0C 83        movsxd      rcx,dword ptr [r11+rax*4]
  00000000000000C2: 4C 03 C9           add         r9,rcx
  00000000000000C5: 49 8D 0C 10        lea         rcx,[r8+rdx]
  00000000000000C9: 4C 03 C9           add         r9,rcx
  00000000000000CC: 49 03 F1           add         rsi,r9
  00000000000000CF: 48 83 ED 01        sub         rbp,1
  00000000000000D3: 0F 85 57 FF FF FF  jne         0000000000000030
  00000000000000D9: 48 8B 5C 24 18     mov         rbx,qword ptr [rsp+18h]
  00000000000000DE: 48 8B C6           mov         rax,rsi
  00000000000000E1: 48 8B 74 24 30     mov         rsi,qword ptr [rsp+30h]
  00000000000000E6: 48 8B 6C 24 20     mov         rbp,qword ptr [rsp+20h]
  00000000000000EB: 41 5E              pop         r14
  00000000000000ED: 5F                 pop         rdi
  00000000000000EE: C3                 ret
--- End of Assembly ---

Assembly Lines:     72 instructions
Comparing Instructions: 7 instructions
Function Call Instructions: 0 instructions

```


## Conclusion

By forcing all call instructions in assembly to be inlined, the corresponding functions are inserted directly into the code. This increases the code size but improves performance by eliminating function call overhead.